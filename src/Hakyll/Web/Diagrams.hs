{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Hakyll.Web.Diagrams where

import           Safe                        (readMay)
import           System.Directory            (createDirectoryIfMissing)
import           System.FilePath
import           System.IO                   (hPutStrLn, stderr)

import qualified Codec.Picture               as J
import           Diagrams.Backend.Rasterific
import qualified Diagrams.Builder            as DB
import           Diagrams.Prelude            (SizeSpec, V2, centerXY, pad, zero,
                                              (&), (.~))
import           Diagrams.TwoD.Size          (mkSizeSpec2D)
import           Text.Pandoc
import           Hakyll
import           Text.ParserCombinators.Parsec
import           Text.Pandoc.SelfContained
import System.FilePath
import Hakyll.Web.Pandoc
import Debug.Trace

buildMarkdown :: Rules ()
buildMarkdown = do
    match "*.md" $ do
      route idRoute
      compile $ pandocCompilerDiagrams

-- | Read a page render using pandoc
pandocCompilerDiagrams :: Compiler (Item String)
pandocCompilerDiagrams = pandocCompilerDiagramsWith defaultHakyllReaderOptions defaultHakyllWriterOptions

pandocCompilerDiagramsWith :: ReaderOptions -> WriterOptions -> Compiler (Item String)
pandocCompilerDiagramsWith ropt wopt = pandocCompilerWithTransformM ropt wopt diagramsTransformer

diagramsTransformer :: Pandoc -> Compiler Pandoc
diagramsTransformer pandoc = unsafeCompiler $ renderBlockDiagrams pandoc

-- | Transform a blog post by looking for code blocks with class
--   @dia@, and replacing them with images generated by evaluating the
--   identifier @dia@ and rendering the resulting diagram.  In
--   addition, blocks with class @dia-def@ are collected (and deleted
--   from the output) and provided as additional definitions that will
--   be in scope during evaluation of all @dia@ blocks.
renderBlockDiagrams :: Pandoc -> IO Pandoc
renderBlockDiagrams p = bottomUpM (renderBlockDiagram defs) p
  where
    defs = queryWith extractDiaDef p

renderInlineDiagrams :: Pandoc -> IO Pandoc
renderInlineDiagrams p = bottomUpM (renderInlineDiagram defs) p
  where
    defs = queryWith extractDiaDef p

extractDiaDef :: Block -> [String]
extractDiaDef (CodeBlock (_, tags, _) src) = if "dia-def" `elem` tags then [src] else []
extractDiaDef _ = []

diaDir :: FilePath
diaDir = "images"  -- XXX make this configurable

-- | Given some code with declarations, some attributes, and an
--   expression to render, render it and return the filename of the
--   generated image (or an error message).
renderDiagram :: Bool         -- ^ Apply padding automatically?
              -> [String]     -- ^ Declarations
              -> String       -- ^ Expression to render
              -> Attr         -- ^ Code attributes
              -> IO (Either String FilePath)
renderDiagram shouldPad decls expr (_ident, _cls, fields) = do
    createDirectoryIfMissing True diaDir
    let bopts = DB.mkBuildOpts Rasterific zero (RasterificOptions sz)
                  & DB.snippets .~ decls
                  & DB.imports  .~ ["Diagrams.Backend.Rasterific"]
                  & DB.diaExpr  .~ expr
                  & DB.postProcess .~ (if shouldPad then pad 1.1 . centerXY else id)
                  & DB.decideRegen .~ (DB.hashedRegenerate (\_ opts -> opts) diaDir)
                  & DB.pragmas .~ ["FlexibleContexts, GADTs"]
    res <- DB.buildDiagram bopts
    case res of
      DB.ParseErr err    -> do
        let errStr = "\nParse error:\n" ++ err
        putErrLn errStr
        return (Left errStr)
      DB.InterpErr ierr  -> do
        let errStr = "\nInterpreter error:\n" ++ DB.ppInterpError ierr
        putErrLn errStr
        return (Left errStr)
      DB.Skipped hash    -> return (Right $ mkFile (DB.hashToHexStr hash))
      DB.OK hash img     -> do
        let imgFile = mkFile (DB.hashToHexStr hash)
        J.savePngImage imgFile (J.ImageRGBA8 img)
        return (Right imgFile)
  where
    sz :: SizeSpec V2 Double
    sz = mkSizeSpec2D (lookup "width" fields >>= readMay) (lookup "height" fields >>= readMay)
    mkFile base = diaDir </> base <.> "png"

renderBlockDiagram :: [String] -> Block -> IO Block
renderBlockDiagram defs c@(CodeBlock attr@(_, cls, _) src)
    | "dia-def" `elem` cls = return Null
    | "dia"     `elem` cls = do
        putStrLn $ "renderBlockDiagram c=" ++ (show c)
        res <- renderDiagram True (src : defs) "dia" attr
        case res of
          Left  err      -> return (CodeBlock attr (src ++ err))
          Right fileName -> return $ Para [Image [] (pathSeparator : fileName, "")]
    | otherwise = return c
renderBlockDiagram _ b = return b

renderInlineDiagram :: [String] -> Inline -> IO Inline
renderInlineDiagram defs c@(Code attr@(_, cls, _) expr)
    | "dia" `elem` cls = do
        res <- renderDiagram False defs expr attr
        case res of
          Left err       -> return (Code attr (expr ++ err))
          Right fileName -> return $ Image [] (fileName, "")
    | otherwise = return c
renderInlineDiagram _ i = return i

putErrLn :: String -> IO ()
putErrLn = hPutStrLn stderr

traceIt :: Show a => String -> a -> a
traceIt s a = trace (s ++ (show a)) a
